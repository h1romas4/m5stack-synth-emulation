// for vgm testing
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "ym2612.hpp"
extern "C" {
#include "sn76496.h"
}

#define SAMPLING_RATE 44100
#define STEREO 2
#define MONO 0

#define VGM_DATA_POS 0x40;

u_int8_t *vgm;
u_int32_t vgmpos;
bool vgmend = false;
bool play = false;

void vgm_load(void) {
    vgm = (unsigned char *) malloc(3000000);
    int fd = open("../../vgm/01.vgm", O_RDONLY);
    read(fd, vgm, 3000000);
    close(fd);
}

u_int8_t get_vgm_ui8()
{
    u_int8_t ret = vgm[vgmpos];
    vgmpos++;
    return ret;
}

u_int16_t get_vgm_ui16()
{
    return get_vgm_ui8() + (get_vgm_ui8() << 8);
}

u_int16_t parse_vgm()
{
    u_int8_t command;
    u_int16_t wait = 0;
    u_int8_t reg;
    u_int8_t dat;

    command = get_vgm_ui8();

    switch (command) {
        case 0x50:
            dat = get_vgm_ui8();
            if(play) SN76496Write(dat);
            break;
        case 0x52:
            reg = get_vgm_ui8();
            dat = get_vgm_ui8();
            if(play) {
                YM2612_Write(0, reg);
                YM2612_Write(1, dat);
            }
            break;
        case 0x53:
            reg = get_vgm_ui8();
            dat = get_vgm_ui8();
            if(play) {
                YM2612_Write(2, reg);
                YM2612_Write(3, dat);
            }
            break;
        case 0x61:
            wait = get_vgm_ui16();
            break;
        case 0x62:
            wait = 735;
            break;
        case 0x63:
            wait = 882;
            break;
        case 0x66:
            vgmend = true;
            break;
        case 0x70: case 0x71: case 0x72: case 0x73: case 0x74: case 0x75: case 0x76: case 0x77:
        case 0x78: case 0x79: case 0x7a: case 0x7b: case 0x7c: case 0x7d: case 0x7e: case 0x7f:
            wait = (command & 0x0f) + 1;
            break;
        case 0x80: case 0x81: case 0x82: case 0x83: case 0x84: case 0x85: case 0x86: case 0x87:
        case 0x88: case 0x89: case 0x8a: case 0x8b: case 0x8c: case 0x8d: case 0x8e: case 0x8f:
            printf("PCM not implement");
            break;
        case 0xe0:
            printf("PCM not implement");
            get_vgm_ui8(); get_vgm_ui8(); get_vgm_ui8(); get_vgm_ui8();
            break;
        default:
            printf("unknown cmd at 0x%x: 0x%x\n", vgmpos, vgm[vgmpos]);
            vgmpos++;
            break;
    }

	return wait;
}

u_int16_t parse_max_frame()
{
    u_int16_t frame_size;
    u_int16_t frame_max_size = 0;

    play = false;
    vgmpos = VGM_DATA_POS;

    do {
        frame_size = parse_vgm();
        if(frame_max_size < frame_size) {
            frame_max_size = frame_size;
        }
    } while(!vgmend);

    play = true;
    vgmend = false;
    vgmpos = VGM_DATA_POS;

    return frame_max_size;
}

short audio_write_sound_stereo(int sample32)
{
    short sample16;

    if (sample32 < -0x7FFF)
        sample16 = -0x7FFF;
    else if (sample32 > 0x7FFF)
        sample16 = 0x7FFF;
    else
        sample16 = (short)(sample32);

    return sample16;
}

// The loop routine runs over and over again forever
int main(void)
{
    vgm_load();

    // Reset for NTSC Genesis/Megadrive
    SN76496_init(3579540, SAMPLING_RATE);
    YM2612_Init(7678453, SAMPLING_RATE, 0);

    size_t bytes_written = 0;

    u_int16_t frame_size;
    u_int32_t frame_all = 0;


    u_int16_t frame_max_size;
    u_int16_t buffer_max_size;
    int **buflr;
    int **DUMMYBUF;

    // parse max frame
    frame_max_size = parse_max_frame();
    buffer_max_size = frame_max_size * sizeof(int);
    printf("buffer_max_size %d\n", buffer_max_size);

    // malloc sound buffer
    buflr = (int **)malloc(sizeof(int) * STEREO);
    buflr[0] = (int *)malloc(buffer_max_size);
    if(buflr[0] == NULL) printf("pcm buffer0 alloc fail.\n");
    buflr[1] = (int *)malloc(buffer_max_size);
    if(buflr[1] == NULL) printf("pcm buffer1 alloc fail.\n");

    int fd = open("../../vgm/01.pcm", O_CREAT | O_WRONLY | O_TRUNC, 0666);

    do {
        frame_size = parse_vgm();
        YM2612_ClearBuffer((int **)buflr, frame_max_size);
        YM2612_Update((int **)buflr, frame_size);
        if(frame_size != 0) {
            for(int i = 0; i < frame_size; i++) {
                short d[2];
                d[0] = audio_write_sound_stereo(buflr[0][i]);
                d[1] = audio_write_sound_stereo(buflr[1][i]);
                write(fd, d, sizeof(short) * 2);
            }
        }
        frame_all += frame_size;
    } while(!vgmend);

    close(fd);

    free(buflr[0]);
    free(buflr[1]);
    free(buflr);

    YM2612_End();

    printf("end!\n");

    return 0;
}
